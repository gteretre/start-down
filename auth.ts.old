import NextAuth from "next-auth";

import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import {
  getAuthorById,
  getAuthorByEmail,
  createAuthor
} from "@/lib/mongodb-service";
//import bcrypt from "bcrypt";

const options = {
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_CLIENT_ID,
      clientSecret: process.env.GITHUB_CLIENT_SECRET
    }),
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      authorization: {
        params: {
          //scope: "openid email profile",
          prompt: "consent",
          access_type: "offline",
          response_type: "code"
        }
      }
    })
  ], // session: {
  //   strategy: "jwt",
  //   maxAge: 24 * 3600, // 1 day
  //   updateAge: 3600 // 1 hour
  // },
  // jwt: {
  //   maxAge: 1 * 24 * 60 * 60, // Token expiration time in seconds (1 day)
  //   encryption: true, // Enable encryption for the JWT
  //   verificationOptions: {
  //     algorithms: ["HS256"] // Algorithms to use for verifying the JWT
  //   }
  // },
  callbacks: {
    async signIn({
      user,
      account,
      profile
    }: {
      user: any;
      account: any;
      profile: any;
    }) {
      try {
        // Only log on server side
        if (typeof window === "undefined") {
          console.log("üîí SECURITY: Sign-in attempt", {
            provider: account?.provider,
            email: user?.email,
            hasProfile: !!profile,
            timestamp: new Date().toISOString()
          });
        }

        // Security check 1: Validate required data exists
        if (!user) {
          if (typeof window === "undefined") {
            console.error(
              "üö® SECURITY ALERT: Sign-in attempt without user data"
            );
          }
          return false;
        } // Security check 2: Validate email
        if (!user.email || !user.email.includes("@")) {
          if (typeof window === "undefined") {
            console.error(
              `üö® SECURITY ALERT: Invalid email format: ${user.email}`
            );
          }
          return false;
        }

        // Security check 3: Validate account provider
        if (!account || !account.provider) {
          if (typeof window === "undefined") {
            console.error(
              "üö® SECURITY ALERT: Missing account provider information"
            );
          }
          return false;
        } // Security check 4: Additional validation based on provider
        if (account.provider === "github" && !profile) {
          if (typeof window === "undefined") {
            console.error(
              "üö® SECURITY ALERT: GitHub login without profile data"
            );
          }
          return false;
        }

        // Determine user ID with appropriate fallbacks and logging
        const userId = profile?.id || user.id;
        if (!userId) {
          if (typeof window === "undefined") {
            console.error(
              "üö® SECURITY ALERT: No user ID available from provider"
            );
          }
          return false;
        }

        if (typeof window === "undefined") {
          console.log("üîç Looking up user by ID:", userId);
        }

        // Try to find existing user by ID with error handling
        let existingUser = null;
        try {
          existingUser = await getAuthorById(userId);
          if (existingUser && typeof window === "undefined") {
            console.log("‚úÖ User found by ID:", existingUser.email);
          }
        } catch (err) {
          if (typeof window === "undefined") {
            console.error("üö® Database error looking up user by ID:", err);
          }
          return false;
        } // If not found by ID, try by email
        if (!existingUser) {
          try {
            existingUser = await getAuthorByEmail(user.email);
            if (existingUser && typeof window === "undefined") {
              console.log("‚úÖ User found by email:", user.email);
            }
          } catch (err) {
            if (typeof window === "undefined") {
              console.error("üö® Database error looking up user by email:", err);
            }
            return false;
          }
        }

        // If user doesn't exist, create a new one with proper validation
        if (!existingUser && typeof window === "undefined") {
          console.log("üÜï Creating new user account for:", user.email);
        }

        // Security check 5: Validate all required fields for new user
        if (!existingUser && !user.name) {
          if (typeof window === "undefined") {
            console.warn("‚ö†Ô∏è Missing user name, using email as fallback");
          }
          user.name = user.email.split("@")[0];
        } // Generate a safe username
        const username =
          profile?.login ||
          user.email.split("@")[0].replace(/[^a-zA-Z0-9]/g, "") ||
          `user_${Date.now().toString().slice(-6)}`;

        if (!existingUser) {
          try {
            await createAuthor({
              id: userId,
              name: user.name,
              username: username,
              email: user.email,
              image: user.image || null,
              bio: profile?.bio || ""
            });
            if (typeof window === "undefined") {
              console.log("‚úÖ New user created successfully:", username);
            }
          } catch (err) {
            if (typeof window === "undefined") {
              console.error(
                "üö® SECURITY ALERT: Failed to create new user:",
                err
              );
            }
            return false;
          }
        }

        if (typeof window === "undefined") {
          console.log("‚úÖ Authentication successful for:", user.email);
        }
        return true;
      } catch (error) {
        if (typeof window === "undefined") {
          console.error(
            "üö® SECURITY ALERT: Unhandled error during sign-in:",
            error
          );
        }
        return false;
      }
    },
    async jwt({ token, user, account, profile }) {
      try {
        // Add request ID for tracking throughout logs
        const requestId = `jwt-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;

        console.log(`üîë [${requestId}] JWT processing initiated:`, {
          hasToken: !!token,
          hasUser: !!user,
          hasAccount: !!account,
          hasProfile: !!profile,
          provider: account?.provider,
          timestamp: new Date().toISOString()
        });

        // Security check 1: Validate token exists
        if (!token) {
          console.error(
            `üö® [${requestId}] SECURITY ALERT: Missing token object in JWT callback`
          );
          return { error: "InvalidToken" };
        }

        // If we have the user object from the sign-in, use it (this happens on sign-in)
        if (user) {
          console.log(
            `‚úÖ [${requestId}] Processing new sign-in for:`,
            user.email || "unknown email"
          );

          // Security check 2: Validate user data integrity
          if (!user.id) {
            console.error(
              `üö® [${requestId}] SECURITY ALERT: User object missing ID`
            );
            token.error = "InvalidUserData";
            return token;
          }

          if (!user.email) {
            console.warn(`‚ö†Ô∏è [${requestId}] User object missing email`);
          }

          // Security check 3: Validate email format if present
          if (
            user.email &&
            (!user.email.includes("@") || user.email.length < 5)
          ) {
            console.error(
              `üö® [${requestId}] SECURITY ALERT: Invalid email format: ${user.email}`
            );
            token.error = "InvalidEmail";
            return token;
          }

          // Make sure we store the user data properly with fallbacks for all fields
          token.user = {
            id: user.id,
            email: user.email || "no-email",
            name: user.name || user.email?.split("@")[0] || "User",
            username:
              user.username ||
              user.email?.split("@")[0] ||
              `user_${Date.now()}`,
            image: user.image || null
          };

          console.log(
            `‚úÖ [${requestId}] Token updated with verified user data:`,
            {
              id: token.user.id,
              email: token.user.email
            }
          );

          // Security check 4: Record the authentication source
          token.authSource = {
            provider: account?.provider || "unknown",
            timestamp: new Date().toISOString(),
            requestId
          };

          return token;
        }

        // Check if we already have user info in the token (this happens on subsequent requests)
        if (token.user && token.user.id) {
          console.log("User already in token:", token.user.id);
          return token;
        }

        // As a fallback, try to fetch from DB using account/profile (shouldn't normally reach here)
        if (account && profile) {
          const userId = profile?.id || account?.providerAccountId;
          console.log("Fetching user from database with ID:", userId);

          const dbUser = await getAuthorById(userId);
          if (dbUser) {
            console.log("Found user in database:", dbUser.name);
            token.user = {
              id: dbUser.id,
              email: dbUser.email,
              name: dbUser.name,
              username: dbUser.username,
              image: dbUser.image
            };
            console.log("Updated token with database user data");
          } else {
            console.error("User not found for ID:", userId);
            token.error = "TokenIncorrect";
          }
        } else if (!token.user) {
          // If we get here with no user data, something is wrong
          console.error("No user data available for JWT token");
          token.error = "NoUserData";
        }
      } catch (error) {
        console.error("Error during JWT token generation:", error);
        token.error = "TokenIncorrect";
      }
      return token;
    },
    async session({ session, token }: { session: any; token: any }) {
      if (token.error === "TokenIncorrect") {
        if (typeof window !== "undefined") {
          alert("Token incorrect. Logging out...");
          await signOut({ redirect: false });
        }
        return null;
      }

      console.log(
        "Session callback received token:",
        JSON.stringify(token, null, 2)
      );

      // Directly flatten the structure to avoid nested objects
      if (token?.user) {
        session.user = {
          id: token.user.id,
          email: token.user.email,
          name: token.user.name,
          username: token.user.username,
          image: token.user.image
        };
        console.log("Session after mapping:", JSON.stringify(session, null, 2));
      } else {
        console.error("User data is missing in the token");
      }

      return session;
    }
  }
};

const { handlers, signIn, signOut, auth } = NextAuth(options);

export { handlers, signIn, signOut, auth };
